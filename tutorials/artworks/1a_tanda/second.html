<!DOCTYPE html>

<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta http-equiv="X-UA-Compatible" content="ie=edge">

		<title>My Second Attempt</title>
		
		<script src="../p5.js"></script>
	</head>

	<style>
		body {
			padding: 0;
			margin: 0;
			height: 100vh;
			width: 100vw;
			border: none;
			overflow: hidden;
		}
	</style>

	<body></body>

	<script>
		var CANVAS_WIDTH, CANVAS_HEIGHT, C;
		const MODE_DEBUG = false;
		const vars    = { };
		const figures = [ ];

		function setup() {
			CANVAS_WIDTH = window.innerWidth;
			CANVAS_HEIGHT = window.innerHeight;
			
			createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
			frameRate( 24 );
			colorMode(HSL);

			getRandomVars();
		}

		function draw() {
			background(45, 100, 95);
			if ( mouseIsPressed ) {
				const col = floor(map( mouseX, 0, CANVAS_WIDTH,  0, vars['cols'] ));
				const row = floor(map( mouseY, 0, CANVAS_HEIGHT, 0, vars['rows'] ));
				figures.push( newRandomFigure( col, row ) );
			}
			noStroke();
			figures.forEach(f => {
				f.update();
				f.display();
			});
			if ( MODE_DEBUG ) drawGird();
		}

		function newRandomFigure( col, row ) {
			const f = floor(random(0, 4));
			var figure;
			switch (f) {
				case 0:  figure = new RectFigure( col, row );     break;
				case 1:  figure = new ArcFigure( col, row );      break;
				case 2:  figure = new TriangleFigure( col, row ); break;
				case 3:  figure = new RectFigure( col, row );     break;
				default: figure = new Figure( col, row );         break;
			}
			return figure
		}

		function getRandomVars() {
			vars['color']  = { 'H': 0, 'S': 100, 'L': 80 };
			vars['cols'] = floor(random( 8, CANVAS_WIDTH  * .015 ));
			vars['rows'] = floor(random( 8, CANVAS_HEIGHT * .015 ));

			if ( MODE_DEBUG ) console.log(vars);
		}

		function drawGird() {
			noFill();
			stroke(0, 0, 60);
			for (let c = 0; c < vars['cols']; c++)
				for (let r = 0; r < vars['rows']; r++) {
					const w = CANVAS_WIDTH  / vars['cols'];
					const h = CANVAS_HEIGHT / vars['rows'];
					rect( c * w, r * h, w, h );
				}
		}

		class Figure {
			constructor(col, row) {
				const colWidth  = CANVAS_WIDTH  / vars['cols'];
				const rowHeight = CANVAS_HEIGHT / vars['rows'];
				this.col = col;
				this.row = row;
				this.posX = this.col * colWidth ;
				this.posY = this.row * rowHeight;
				this.size = floor(random( 1, vars['cols'] * .25 )) * colWidth;
				this.colorHue = floor(random( 0, 360 ));
				this.f = 0;
				this.speed = random( -.01, .01 );
			}
			update() {
				if (abs(this.f) < 1) this.f += this.speed;
				//else eliminar de la llista 'figures'.
			}
			display() {
				this.setFillColor();
				const s = this.size * this.f;
				rect(this.posX, this.posY, s, s);
			}
			setFillColor() {
				fill(this.colorHue, vars['color']['S'], vars['color']['L']);
			}
		}

		class RectFigure extends Figure {
			constructor(col, row) {
				super(col, row);
				const colWidth  = CANVAS_WIDTH  / vars['cols'];
				const rowHeight = CANVAS_HEIGHT / vars['rows'];
				this.sizeX = floor(random( 1, vars['cols'] * .25 )) * colWidth;
				this.sizeY = floor(random( 1, vars['rows'] * .25 )) * rowHeight;
				this.fx = 0;
				this.fy = 0;
			}
			update() {
				if ( abs(this.fx) < 1) this.fx += this.speed;
				if ( abs(this.fy) < 1) this.fy += this.speed;
			}
			display() {
				this.setFillColor();
				rect( this.posX, this.posY, this.sizeX * this.fx, this.sizeY * this.fy );
			}
		}

		class CircleFigure extends Figure {
			constructor(col, row) {
				super(col, row);
				const colWidth  = CANVAS_WIDTH  / vars['cols'];
				const rowHeight = CANVAS_HEIGHT / vars['rows'];
				this.posX = this.col * colWidth  + this.size * .5;
				this.posY = this.row * rowHeight + this.size * .5;
			}
			display() {
				this.setFillColor();
				circle(this.posX, this.posY, this.size * this.f);
			}
		}

		class ArcFigure extends CircleFigure {
			constructor(col, row) {
				super(col, row);
				this.a = floor(random(0, 4)) * HALF_PI;
				this.speed = abs(this.speed);
				this.size = floor(random( 1, vars['cols'] * .25 ));
				const colWidth  = CANVAS_WIDTH  / vars['cols'];
				const rowHeight = CANVAS_HEIGHT / vars['rows'];
				if ( sin(this.a) == 0 ) this.size = floor(random( 1, vars['cols'] * .25 )) * colWidth;
				else                    this.size = floor(random( 1, vars['rows'] * .25 )) * rowHeight;
				this.posX = this.col * colWidth  + this.size * .5;
				this.posY = this.row * rowHeight + this.size * .5;
			}
			display() {
				this.setFillColor();
				const a0 = this.a;
				const a1 = a0 + PI * this.f;
				arc(this.posX, this.posY, this.size, this.size, a0, a1, PIE);
			}
		}

		class TriangleFigure extends RectFigure {
			constructor(col, row) {
				super(col, row);
				this.speed = abs(this.speed);
			}
			display() {
				this.setFillColor();
				const p1x = this.posX;
				const p1y = this.posY;
				const p2x = this.posX;
				const p2y = this.posY + this.sizeY;
				const p3x = this.posX + this.sizeX * this.fx;
				const p3y = this.posY + this.sizeY;
				triangle(p1x, p1y, p2x, p2y, p3x, p3y);
			}
		}

	</script>

</html>